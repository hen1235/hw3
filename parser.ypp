%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	int whileFlag = 0;
	bool mainExist = false;
 	type_t funcType = _NULL;
	extern int yylex();
	extern int yylineno;
	extern char * yytext;
	int yyerror(const char * message);
	void match_operands(type_t type1, type_t type2, bool flag);
	stack<Tuple> tables;
	stack<int> offsets;
	vector<Var> args, params;
	type_t get_variable_type(string name);
	bool check_func_exist(string name, vector<Var> argList);
	vector<string> get_args(Var var);
	int get_arr_size_and_type(string name, type_t* type, int* size);
	string types[6] = {"INT","BOOL","STRING","BYTE","VOID","NONE"};
%}



%token ID NUM B STRING TRUE FALSE VOID INT
%token IF
%nonassoc IFX
%nonassoc ELSE 
%token BOOL BREAK COMMA BYTE RETURN SC WHILE ERROR
%right ASSIGN 
%left OR
%left AND
%left EQ NEQ
%nonassoc LT GT LTE GTE
%left ADD SUB
%left DIV MUL
%right NOT
%left LBRACE RBRACE
%left LBRACK RBRACK LPAREN RPAREN 



%%

Program	:	
		{
			/* insert print function to symbol table */
			Tuple tuple;
			vector<Var> printArgs;
			Var var1 = {_STRING,0,"a"};
			printArgs.push_back(var1);
			BaseRecord* printRecord = new FuncRecord("print",_VOID,printArgs);
			tuple.table.push_back(printRecord);

			// FuncRecord* funcRecord = dynamic_cast<FuncRecord*>(print.table.back());
			// if(funcRecord != NULL){
			// 	// cout << funcRecord->args[0] << " *****\n" << endl;
			// }

			/* insert printi function to symbol table */
			vector<Var> printiArgs;
			Var var2 = {_INT,0,"a"}; 
			printiArgs.push_back(var2);
			BaseRecord* printiRecord = new FuncRecord("printi",_VOID,printiArgs);
			tuple.table.push_back(printiRecord);

			tuple.parent = NULL;
			tables.push(tuple);
			offsets.push(0);
			// cout << tables.top().table.size() << " $$$$" << endl;

		} Funcs 
		{ 
			// cout << mainExist << endl;
			if(mainExist == false){
				errorMainMissing();
				exit(0);
			} 
		} CLOSESCOPE

		;

Funcs	: /* epsilon */
		| FuncDecl Funcs
		;

FuncDecl	:  RetType 
			{ 
				funcType = $1.type;
				// cout << $1.type << endl; 
			} 
				ID
			{ 					
				if($3.name == "main"){
					mainExist = true;
				}
				// cout << "here "<< endl;
				$3.type = $1.type;	

			} LPAREN Formals RPAREN 
			{
				
				if(check_func_exist($3.name, args)){
					errorDef(yylineno, $3.name);
					exit(0);
				}
				BaseRecord* funcRecord = new FuncRecord($3.name, $1.type, args);
				
				//cout << $3.name << " " << $1.type << " " << dynamic_cast<FuncRecord*>(funcRecord)->args[0] << endl;
				tables.top().table.push_back(funcRecord);
				// FuncRecord* tmp = dynamic_cast<FuncRecord*>((tables.top().table).back());
				// cout << tmp->args[0] << " ******\n" << endl;
				// cout << tables.top().table.size() << " -----" << endl;
				
				
			}	LBRACE OPENSCOPE 
			{
				// cout << "here" << endl;

				for(vector<Var>::iterator it = args.begin(); it != args.end(); ++it){
					BaseRecord* record =  new Record(it->name,it->type,offsets.top()-1);
					tables.top().table.push_back(record);
					offsets.top()++;
				}
				args.clear();
			} Statments CLOSESCOPE RBRACE { funcType = _NULL; }
			;


RetType	: Type { $$.type = $1.type;}
		| VOID { $$.type = _VOID; }
		;

Formals	: /* epsilon */
		| FormalsList
		;

FormalsList	: FormalDecl
			| FormalDecl COMMA FormalsList
			;

FormalDecl	: Type ID
			{ 
				// cout << "here\n" << endl;
				Var var = {$1.type,0,$2.name};

				args.push_back(var);
				
				// cout << "size = " << tables.top().table.size() << "\n" << endl;
				// cout << tmp->name << " " << tmp->offset << "\n" << endl;
				// cout << tables.top().table.size() << " ****\n" << endl;
			}
			| Type ID LBRACK NUM RBRACK 
			{ 
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				Var var = {$1.type,0,$2.name};
				args.push_back(var);
				BaseRecord* arrRecord =  new ArrRecord($2.name,$2.type,offsets.top()-$4.val,$4.val);
				tables.top().table.push_back(arrRecord); 
			}
			| Type ID LBRACK NUM B RBRACK 
			{ 
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				Var var = {$1.type,0,$2.name};
				args.push_back(var);
				BaseRecord* arrRecord = new ArrRecord($2.name,$2.type,offsets.top()-$4.val,$4.val);
				tables.top().table.push_back(arrRecord); 

			}
			;

Statments	: Statement
			| Statments Statement
			;

Statement 	: LBRACE OPENSCOPE Statments CLOSESCOPE RBRACE
			| Type ID SC
			{ 
				// cout << "here" << endl;
				type_t type = get_variable_type($2.name);
				if(type != _NULL){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				$2.type = $1.type;
				$2.size = -1;
				BaseRecord* record = new Record($2.name, $1.type, offsets.top());
				tables.top().table.push_back(record);
				offsets.top()++;

			}
			| Type ID ASSIGN Exp SC
			{ 
				// cout << "here1" << endl;
				type_t type = get_variable_type($2.name);
				if(type != _NULL){
					errorUndef(yylineno, $2.name);
					exit(0);
				}
				// if($4.size != -1){
				// 	errorMismatch(yylineno);
				// 	exit(0);
				// }
				else if($1.type == _INT && ($4.type != _INT && $4.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type != _INT && $1.type != $4.type){
					errorMismatch(yylineno); 
					exit(0); 
				}

				$2.type = $1.type;
				$2.size = -1;
				BaseRecord* record = new Record($2.name, $1.type, offsets.top());
				tables.top().table.push_back(record);
				offsets.top()++;
			}
			| Type ID LBRACK NUM RBRACK SC
			{ 
				// cout << "here2" << endl;
				type_t type;
				int size, res;
				res = get_arr_size_and_type($2.name, &type, &size);
				type = get_variable_type($2.name);
				if(res == 0 || type != _NULL){
					// cout << res << " " << type << " " << $4.val << endl;
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				$2.type = $1.type;
				$2.size = $4.val;
				// cout << $4.val << " ***2***"<< $2.type << endl;
				BaseRecord* record = new ArrRecord($2.name, $1.type, offsets.top(), $2.size);
				tables.top().table.push_back(record);
				offsets.top()+=$2.size;
			}
			| Type ID LBRACK NUM B RBRACK SC
			{ 
				// cout << "here3" << endl;				
				type_t type;
				int size, res;
				res = get_arr_size_and_type($2.name, &type, &size);
				type = get_variable_type($2.name);
				if(res == 0 || type != _NULL){
					errorDef(yylineno, $2.name);
					exit(0);
				}
				if($4.val <= 0 || $4.val >= 256){
					errorInvalidArraySize(yylineno,$2.name);
					exit(0);
				}
				$2.type = $1.type;
				$2.size = $4.val;
				// cout << $4.val << " ***1***"<< endl;
				BaseRecord* record = new ArrRecord($2.name, $1.type, offsets.top(), $2.size);
				tables.top().table.push_back(record);
				offsets.top()+=$2.size;
			}
			| ID ASSIGN Exp SC 
			{
				type_t type1, type2;
				int size, res;
				if((res = get_arr_size_and_type($1.name, &type1, &size)) == -1 && 
					(type2 = get_variable_type($1.name)) == _NULL){ // ID var or arr don't exist
					errorUndef(yylineno, $1.name);
					exit(0);
				}
				else if(res == 0){ // ID is arr
					$1.type = type1;
					$1.size = size;
				}
				else if(type2 != _NULL){ // ID is var
					$1.type = type2;
					$1.size = -1;
				}
				if((res = get_arr_size_and_type($3.name, &type1, &size)) == -1 && 
					(type2 = get_variable_type($3.name)) == _NULL){ // Exp var or arr don't exist
					errorUndef(yylineno, $3.name);
					exit(0);
				}
				else if(res == 0){ // Exp is arr
					$3.type = type1;
					$3.size = size;
				}
				else if(type2 != _NULL){ // Exp is var
					$3.type = type2;
					$3.size = -1;
				}

				// cout << $1.size << " " << $3.size << endl;
				if($3.size != $1.size){
					errorMismatch(yylineno);
					exit(0);
				}
				else if($1.type == _INT && ($3.type != _INT && $3.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type != _INT && $1.type != $3.type){
					errorMismatch(yylineno); 
					exit(0); 
				}
			}
			| ID LBRACK Exp RBRACK ASSIGN Exp SC
			{
				// cout << "****** array assignment ********" << endl;
				type_t type;
				int size, res;
				res = get_arr_size_and_type($1.name, &type, &size);
				if(res == -1){
					errorUndef(yylineno, $1.name);
					exit(0);
				}
				// cout << $1.size << " " << $6.size << endl;
				$1.type = type;
				$1.size = size;
				type = get_variable_type($6.name);
				if(type == _NULL){
					errorMismatch(yylineno); 
					exit(0); 					
				}
				if($3.type != _INT && $3.type != _BYTE){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _INT && ($6.type != _INT && $6.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BYTE && $6.type != _BYTE){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BOOL && $6.type !=_BOOL){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _STRING && $6.type !=_STRING){
					errorMismatch(yylineno); 
					exit(0); 
				}



			}
			| Call SC
			| RETURN SC 
			{ 
				if(funcType != _VOID){ 
					errorMismatch(yylineno); 
					exit(0); 
				}
			}
			| RETURN Exp SC 
			{ 
				// cout << $2.type << " " << funcType << endl;
				if (funcType == _INT && ($2.type != _INT && $2.type != _BYTE)){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if(funcType != _INT && funcType != $2.type){ 
					errorMismatch(yylineno); 
					exit(0); 
				}
			}
			| IF LPAREN IfExp RPAREN OPENSCOPE Statement CLOSESCOPE %prec IFX

			| IF LPAREN IfExp RPAREN OPENSCOPE Statement CLOSESCOPE ELSE OPENSCOPE Statement CLOSESCOPE

			| WHILE LPAREN Exp RPAREN 
				{ whileFlag = 1; } OPENSCOPE Statement CLOSESCOPE { whileFlag = 0; }
			| BREAK SC 
			{ 
				if(!whileFlag){ 
					errorUnexpectedBreak(yylineno); 
					exit(0);
				}
			}
			;

IfExp 	: Exp 			
		{
			// cout << "$3.type = " << $3.type << endl;
			if($1.type != _BOOL){
			// cout << "here" << endl;
				errorMismatch(yylineno);
				exit(0);
			}
		}
		;
Call	: ID LPAREN ExpList RPAREN
 		{
 			//vector<Var> argList = params;
 			//
 			// cout << $1.name << " " << argList[0] << "\n" << endl;
			if(!check_func_exist($1.name, params)){
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			$$.type = $1.type;
			params.clear();

		}
		| ID LPAREN RPAREN 
		{
			if(!check_func_exist($1.name, vector<Var>())){
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			$$.type = $1.type;

		}
		;

ExpList	: Exp { Var var = {$1.type, $1.size, $1.name}; params.push_back(var); }
		| Exp COMMA ExpList { Var var = {$1.type, $1.size, $1.name}; params.push_back(var); }
		;

Type 	: INT { $$.type = _INT; }
		| BYTE { $$.type = _BYTE; }
		| BOOL { $$.type = _BOOL; }
		;

Exp 	: LPAREN Exp RPAREN { $$ = $2; }
		| ID LBRACK Exp RBRACK	
		{ 
			// cout << "here1" << endl;
			type_t type = _NULL;

			int size, res;
			res = get_arr_size_and_type($1.name, &type, &size);
			if(res == -1){
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			// cout << "type = " << type << endl;
			if($3.type != _BYTE && $3.type != _INT){
				// cout << "here" << endl;
				errorMismatch(yylineno);
				exit(0);
			}
			// cout << "here2" << endl;

			$$.type = $1.type = type;
			$$.size = -1;

		} 
		| Exp SUB Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp ADD Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp MUL Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp DIV Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| ID
		{ 
			type_t type = get_variable_type($1.name);
			if(type == _NULL){
				errorUndef(yylineno, $1.name);
				exit(0);
			}
			$1.type = type;
			// $1.size = -1;
			$$ = $1; 
		}
		| Call { $$ = $1; }
		| NUM { $$.type = _INT; $$.val = $1.val; }
		| NUM B { $$.type = _BYTE; $$.val = $1.val; }
		| STRING  { $$.type = _STRING; }
		| TRUE { $$.type = _BOOL;}
		| FALSE { $$.type = _BOOL; }
		| NOT Exp { if($2.type != _BOOL){
						errorMismatch(yylineno);
						exit(0);
						} 
					$$.type = _BOOL;
				}
		| Exp AND Exp { match_operands($1.type,$3.type,false); $$.type = _BOOL; }
		| Exp OR Exp { match_operands($1.type,$3.type,false); $$.type = _BOOL; }
		| Exp EQ Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		| Exp NEQ Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		| Exp LT Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		| Exp GT Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		| Exp LTE Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		| Exp GTE Exp { match_operands($1.type,$3.type,true); $$.type = _BOOL; }
		;

OPENSCOPE	: {
				Tuple tuple;
				tuple.parent = &(tables.top());
				tables.push(tuple);
				offsets.push(offsets.top());
			}
			;

CLOSESCOPE	: {
				endScope();
				// cout << "ok0\n" << endl;
				Tuple* tuple = &(tables.top());
				vector<BaseRecord*>* table = &(tuple->table);
				//cout << tables.top().table.size() << " ****\n" << endl;
				Record* record;
				ArrRecord* arrRecord;
				FuncRecord* funcRecord;
				for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
					// cout << table->size() << " ****\n" << endl;

					arrRecord = dynamic_cast<ArrRecord*>(*it);
					if(arrRecord != NULL){ // record of array
						// cout << "ok\n" << endl;
						printID(arrRecord->name,arrRecord->offset,makeArrayType(types[arrRecord->type],arrRecord->size));
						continue;
					}
					// cout << "ok4\n" << endl;

					record = dynamic_cast<Record*>(*it);
					if(record != NULL){ // record of variable
						// cout << "ok1\n" << endl;
						printID(record->name, record->offset, types[record->type]);
						continue;
					}

					// cout << "ok3\n" << endl;
					funcRecord = dynamic_cast<FuncRecord*>(*it);
					if(funcRecord != NULL){ // record of function
						// cout << "ok2\n" << endl;
						vector<string> tmp;
						for(vector<Var>::iterator it = funcRecord->args.begin(); it != funcRecord->args.end(); ++it){
							tmp.push_back(types[it->type]);
						}
						printID(funcRecord->name, 0, makeFunctionType(types[funcRecord->type],tmp));
						continue;
					}
					
				}
				tables.pop();
				offsets.pop();
			}
			;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(0);
}

/* flag == true checks for numeric types, type == false checks for bool value */
void match_operands(type_t type1, type_t type2, bool flag){
	// cout << type1 << " " << type2 << " " << flag << endl;
	if (flag == true){
		if((type1 != _INT && type1 != _BYTE) || (type2 != _INT && type2 != _BYTE)){
			// cout << "here" << endl;
			errorMismatch(yylineno);
			exit(0);
		}
	}
	else if (flag == false){
		if((type1 != _BOOL) || (type2 != _BOOL)){
			// cout << "here1" << endl;
			errorMismatch(yylineno);
			exit(0);
		}
	}
}

/* return true if varialbe was declared, false if not */
type_t get_variable_type(string name){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	Record* record;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			record = dynamic_cast<Record*>(*it);
			if(record == NULL){
				continue;
			}
			if(record->name == name){
				return record->type;
			}
		}
		tuple = tuple->parent;
	}
	return _NULL;
}

int get_arr_size_and_type(string name, type_t* type, int* size){
	if(!type || !size){
		return -1;
	}

	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	ArrRecord* arrRecord;
	while(tuple != NULL){
		table = &(tuple->table);
		for(vector<BaseRecord*>::iterator it = table->begin(); it != table->end(); ++it){
			arrRecord = dynamic_cast<ArrRecord*>(*it);
			if(arrRecord == NULL){
				continue;
			}
			if(arrRecord->name == name){
				// cout << arrRecord->name  << " " << arrRecord->type << " " << arrRecord->size << endl;
				*type = (arrRecord->type);
				*size = (arrRecord->size);
				return 0;
			}
		}
		tuple = tuple->parent;
	}
	return -1;
}

bool check_func_exist(string name, vector<Var> argList){
	Tuple *tuple = &(tables.top());
	vector<BaseRecord*>* table;
	FuncRecord* funcRecord;
	BaseRecord* baseRecord;
	while(tuple != NULL){
		table = &(tuple->table);

		for(vector<BaseRecord*>::iterator it = tuple->table.begin(); it != tuple->table.end(); ++it){
			//cout << it->name << "\n" << endl;
			funcRecord = dynamic_cast<FuncRecord*>(*it);
			if(funcRecord == NULL){
				continue;
			}
			// cout << funcRecord->name << " /////\n" << endl;
			if(funcRecord->name == name /*&& argList == funcRecord->args*/){
				return true;
			}
		}
		tuple = tuple->parent;
	}
	return false;
}


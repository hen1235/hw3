%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	int whileFlag = 0;
	type_t funcType = _NONE;
	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
	void match_operands(type_t type1, type_t type2, bool flag);
%}



%token ID NUM B STRING TRUE FALSE VOID INT
%nonassoc IFX
%nonassoc ELSE 
%token BOOL BREAK COMMA BYTE IF RETURN SC WHILE ERROR
%right ASSIGN 
%left OR
%left AND
%left EQ NEQ
%nonassoc LT GT LTE GTE
%left ADD SUB
%left DIV MUL
%right NOT
%left LBRACE RBRACE
%left LBRACK RBRACK LPAREN RPAREN 



%%

Program	:	Funcs
		;

Funcs	: /* epsilon */
		| FuncDecl Funcs
		;

FuncDecl	:  RetType { funcType = $1.type; } 
				ID LPAREN Formals RPAREN LBRACE Statments 
				{ funcType = _NONE; } RBRACE
			;


RetType	: Type
		| VOID
		;

Formals	: /* epsilon */
		| FormalsList
		;

FormalsList	: FormalDecl
			| FormalDecl COMMA FormalsList
			;

FormalDecl	: Type ID
			| Type ID LBRACK NUM RBRACK
			| Type ID LBRACK NUM B RBRACK
			;

Statments	: Statement
			| Statments Statement
			;

Statement 	: LBRACE Statments RBRACE
			| Type ID SC { }
			| Type ID ASSIGN Exp SC
			| Type ID LBRACK NUM RBRACK SC
			| Type ID LBRACK NUM B RBRACK SC
			| ID ASSIGN Exp SC 
			{ 
				if($1.type == _INT && ($3.type != _INT && $3.type != _BYTE )){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BYTE && $3.type != _BYTE){
					errorMismatch(yylineno); 
					exit(0); 
				}
				else if($1.type == _BOOL && ($3.type != _INT && $3.type != _BYTE)){
					errorMismatch(yylineno); 
					exit(0); 
				}

			}
			| ID LBRACK Exp RBRACK ASSIGN Exp SC
			| Call SC
			| RETURN SC { if(funcType != _VOID){ 
							errorMismatch(yylineno); 
							exit(0); 
							}
						}
			| RETURN Exp SC { if(funcType != $2.type){ 
								errorMismatch(yylineno); 
								exit(0); 
								}
							}
			| IF LPAREN Exp RPAREN Statement %prec IFX
			| IF LPAREN Exp RPAREN Statement ELSE Statement
			| WHILE LPAREN Exp RPAREN 
				{ whileFlag = 1; } Statement { whileFlag = 0; }
			| BREAK SC { if(!whileFlag){ 
							errorUnexpectedBreak(yylineno); 
							exit(0);
							}
						}
			;

Call	: ID LPAREN ExpList RPAREN
		| ID LPAREN RPAREN
		;

ExpList	: Exp
		| Exp COMMA ExpList
		;

Type 	: INT { $$.type = _INT; }
		| BYTE { $$.type = _BYTE; }
		| BOOL { $$.type = _BOOL; }
		;

Exp 	: LPAREN Exp RPAREN { if($2.type != _INT){
								errorMismatch(yylineno);
								exit(0);
								} 
							$$ = $2; 
						}
		| ID LBRACK Exp RBRACK	// array derefrence
		| Exp SUB Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp ADD Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp MUL Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| Exp DIV Exp { match_operands($1.type,$3.type,true); $$.type = _INT; }
		| ID { $$ = $1; }
		| Call { $$ = $1; }
		| NUM { $$.type = _INT; }
		| NUM B { $$.type = _BYTE; }
		| STRING  { $$.type = _STRING; }
		| TRUE { $$.type = _BOOL;}
		| FALSE { $$.type = _BOOL; }
		| NOT Exp { if($2.type != _BOOL){
						errorMismatch(yylineno);
						exit(0);
						} 
					$$.type = _BOOL;
				}
		| Exp AND Exp { match_operands($1.type,$2.type,false); $$.type = _BOOL; }
		| Exp OR Exp { match_operands($1.type,$2.type,false); $$.type = _BOOL; }
		| Exp EQ Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		| Exp NEQ Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		| Exp LT Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		| Exp GT Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		| Exp LTE Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		| Exp GTE Exp { match_operands($1.type,$2.type,true); $$.type = _BOOL; }
		;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}

/* flag == true checks for numeric type, type == false checks for bool value */
void match_operands(type_t type1, type_t type2, bool flag){
	if (flag == true){
		if((type1 != _INT && type1 != _BYTE) || (type2 != _INT && type2 != _BYTE)){
			errorMismatch(yylineno);
			exit(0);
		}
	}
	else if (flag == false){
		if((type1 != _BOOL) || (type2 != _BOOL)){
			errorMismatch(yylineno);
			exit(0);
		}
	}
}


/*type_t get_type(type_t var){



	return _VOID;
}*/
